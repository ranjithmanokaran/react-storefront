{"version":3,"sources":["../src/serviceWorker.js"],"names":["prefetched","Set","waitForServiceWorker","navigator","serviceWorker","ready","Promise","resolve","then","controller","addEventListener","prefetch","url","process","env","NODE_ENV","SERVICE_WORKER","toString","has","add","link","document","createElement","relList","rel","supports","setAttribute","addPrefetchParam","head","append","prefetchJsonFor","prefetchQueryParam","RSF_PREFETCH_QUERY_PARAM","parsed","URL","location","href","hostname","searchParams","resetPrefetches","clear"],"mappings":"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","sourcesContent":["import getAPIURL from './api/getAPIURL'\nimport addVersion from './api/addVersion'\n\nconst prefetched = new Set()\n\n/**\n * Resolves when the service worker has been installed.\n * @private\n */\nexport function waitForServiceWorker() {\n  if (!navigator.serviceWorker || !navigator.serviceWorker.ready) {\n    return false\n  }\n\n  return new Promise(resolve => {\n    navigator.serviceWorker.ready.then(() => {\n      if (navigator.serviceWorker.controller) {\n        return resolve(true)\n      }\n      navigator.serviceWorker.addEventListener('controllerchange', () => {\n        return resolve(true)\n      })\n    })\n  })\n}\n\n/**\n * Prefetches the specified URL. This function will wait for the service worker\n * to be installed to ensure that it has the opportunity to cache the response.\n * @param {String} url The URL to prefetch\n */\nexport async function prefetch(url) {\n  if (url == null) return\n\n  if (process.env.NODE_ENV !== 'production' && process.env.SERVICE_WORKER !== 'true') {\n    // note that even though we wait for the service worker to be available, during local\n    // development it is still possible for a service worker to be around from a previous\n    // build of the app, so we disable prefetching in development unless process.env.SERVICE_WORKER = true\n    // so that prefetching does not slow bog down the local node server and slow down development\n    return\n  }\n\n  url = addVersion(url).toString()\n\n  if (prefetched.has(url)) {\n    return\n  }\n\n  prefetched.add(url)\n  await waitForServiceWorker()\n  const link = document.createElement('link')\n  const { relList } = link\n\n  const rel =\n    relList.supports('preload') && /* istanbul ignore next */ !relList.supports('prefetch')\n      ? /* istanbul ignore next */ 'preload'\n      : 'prefetch' // Safari does not support prefetch so we use preload instead\n\n  link.setAttribute('href', addPrefetchParam(url))\n  link.setAttribute('as', 'fetch')\n  link.setAttribute('rel', rel)\n  document.head.append(link)\n}\n\n/**\n * Prefetches the JSON API results for a given page\n * @param {String} url The page URL.\n */\nexport function prefetchJsonFor(url) {\n  return prefetch(getAPIURL(url))\n}\n\n/**\n * Adds process.env.PREFETCH_QUERY_PARAM to the URL so that back ends can identify prefetch requests and\n * potentially ignore them during periods of high traffic.\n * @param {String} url\n * @return {String} A new URL\n */\nfunction addPrefetchParam(url) {\n  const prefetchQueryParam = process.env.RSF_PREFETCH_QUERY_PARAM\n\n  if (prefetchQueryParam) {\n    const parsed = new URL(url, location.href)\n\n    if (parsed.hostname === location.hostname) {\n      // only add __prefetch__ for requests going back to Layer0.\n      parsed.searchParams.append(prefetchQueryParam, '1')\n    }\n\n    return parsed.toString()\n  } else {\n    return url\n  }\n}\n\n/**\n * Clears the set which keeps track of which URLs have been prefetched so\n * they can be prefetched again.\n */\nexport function resetPrefetches() {\n  prefetched.clear()\n}\n"],"file":"serviceWorker.js"}