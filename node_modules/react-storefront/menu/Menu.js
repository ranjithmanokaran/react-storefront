"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.styles = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _styles = require("@material-ui/core/styles");

var _menuStyles = _interopRequireDefault(require("./menuStyles"));

var _MenuContext = _interopRequireDefault(require("./MenuContext"));

var _Drawer = _interopRequireDefault(require("@material-ui/core/Drawer"));

var _clsx2 = _interopRequireDefault(require("clsx"));

var _SEOLinks = _interopRequireDefault(require("./SEOLinks"));

var _MenuBody = _interopRequireDefault(require("./MenuBody"));

var _propTypes = _interopRequireDefault(require("prop-types"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var styles = _menuStyles["default"];
exports.styles = styles;
var useStyles = (0, _styles.makeStyles)(styles, {
  name: 'RSFMenu'
});

var Menu = /*#__PURE__*/_react["default"].memo(function (props) {
  var classes = props.classes,
      className = props.className,
      anchor = props.anchor,
      drawerWidth = props.drawerWidth,
      persistent = props.persistent,
      root = props.root,
      open = props.open,
      onClose = props.onClose,
      renderFooter = props.renderFooter,
      renderHeader = props.renderHeader,
      renderBack = props.renderBack,
      renderItem = props.renderItem,
      renderItemContent = props.renderItemContent,
      renderDrawer = props.renderDrawer,
      others = (0, _objectWithoutProperties2["default"])(props, ["classes", "className", "anchor", "drawerWidth", "persistent", "root", "open", "onClose", "renderFooter", "renderHeader", "renderBack", "renderItem", "renderItemContent", "renderDrawer"]);
  classes = useStyles({
    classes: classes
  });

  var _useState = (0, _react.useState)(function () {
    return {
      card: 0,
      cards: [_objectSpread(_objectSpread({}, root), {}, {
        root: true
      })]
    };
  }),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1]; // this is needed so we can always update the *current* state, not the snapshot that
  // was present when the callbacks were memoized


  var stateRef = (0, _react.useRef)(state);
  (0, _react.useEffect)(function () {
    stateRef.current = state;
  }, [state]);
  (0, _react.useEffect)(function () {
    setState({
      card: 0,
      cards: [_objectSpread(_objectSpread({}, root), {}, {
        root: true
      })]
    });
  }, [root]); // this ensures that the expanded state is reset when showing a new card

  var nextKey = (0, _react.useRef)(0);

  var onItemClick = function onItemClick(item, depth) {
    var cards = (0, _toConsumableArray2["default"])(stateRef.current.cards);
    var card = depth + 1;
    item.key = nextKey.current++; // this ensures that the expanded state is reset when showing a new card

    if (card >= cards.length) {
      cards.push(item);
    } else {
      cards[card] = item;
    }

    setState({
      card: card,
      cards: cards.slice(0, card + 1)
    });
  };

  var goBack = function goBack(card) {
    setState({
      card: card,
      cards: stateRef.current.cards
    });
  }; // it is important to memoize the context, otherwise it will cause all consumers to rerender
  // every time Menu rerenders


  var context = (0, _react.useMemo)(function () {
    return {
      classes: classes,
      onItemClick: onItemClick,
      goBack: goBack,
      renderFooter: renderFooter,
      renderHeader: renderHeader,
      renderBack: renderBack,
      renderItem: renderItem,
      renderItemContent: renderItemContent,
      close: onClose,
      drawerWidth: drawerWidth
    };
  }, [classes]);
  return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, /*#__PURE__*/_react["default"].createElement(_MenuContext["default"].Provider, {
    value: context
  }, renderDrawer ? renderDrawer() : /*#__PURE__*/_react["default"].createElement(_Drawer["default"], {
    variant: persistent ? 'persistent' : 'temporary',
    open: open || persistent,
    onClose: onClose,
    anchor: anchor,
    ModalProps: {
      keepMounted: true
    },
    PaperProps: {
      style: {
        width: "".concat(drawerWidth, "px")
      }
    },
    classes: {
      root: className,
      paper: (0, _clsx2["default"])(classes.drawer, (0, _defineProperty2["default"])({}, classes.drawerFixed, persistent)),
      modal: classes.modal
    }
  }, /*#__PURE__*/_react["default"].createElement(_MenuBody["default"], (0, _extends2["default"])({
    card: state.card,
    cards: state.cards,
    root: root,
    drawerWidth: drawerWidth
  }, others))), /*#__PURE__*/_react["default"].createElement(_SEOLinks["default"], {
    root: root
  })));
});

Menu.propTypes = {
  root: _propTypes["default"].object,

  /**
   * The width of the drawer in pixels
   */
  drawerWidth: _propTypes["default"].number,

  /**
   * An element to display at the top of the root of the menu
   */
  rootHeader: _propTypes["default"].element,

  /**
   * An element to display at the bottom of the root of the menu
   */
  rootFooter: _propTypes["default"].element,

  /**
   * A function to render a custom header in menu cards.  It is passed an object
   * with:
   *
   * - item: The menu item record being rendered
   *
   * The function should return a React element or fragment.
   */
  renderHeader: _propTypes["default"].func,

  /**
   * A function to render a custom footer menu cards.  It is passed an object
   * with:
   *
   * - item: The menu item record being rendered
   *
   * The function should return a React element or fragment.
   */
  renderFooter: _propTypes["default"].func,

  /**
   * A function to render a custom back navigation for menu cards.  It is passed
   * an object with:
   *
   * - item: The menu item record being rendered
   *
   * The function should return a React element or fragment.
   */
  renderBack: _propTypes["default"].func,

  /**
   * Set to true to display the menu
   */
  open: _propTypes["default"].bool,

  /**
   * Set to true to dock the menu so that it's always open and not modal
   */
  persistent: _propTypes["default"].bool,

  /**
   * CSS classes for this component
   */
  classes: _propTypes["default"].objectOf(_propTypes["default"].string),

  /**
   * Called when the menu is closed
   */
  onClose: _propTypes["default"].func,

  /**
   * The icon to use for collapsed groups
   */
  ExpandIcon: _propTypes["default"].elementType,

  /**
   * The icon to use for expanded groups
   */
  CollapseIcon: _propTypes["default"].elementType,

  /**
   * Sets the side of the screen from which the menu appears.
   */
  anchor: _propTypes["default"].oneOf(['left', 'right']),

  /**
   * Overrides the default rendering of a menu item.  It is passed the following arguments:
   *
   * - item - the menu item record being rendered.
   *
   * Return undefined to render the default contents
   *
   * Example:
   *
   * ```js
   *  renderItem={item => {
   *    return item.text === 'My Special Item ? <MySpecialItem/> : null
   *  }}
   * ```
   */
  renderItem: _propTypes["default"].func,

  /**
   * Overrides the content of a menu item.  It is passed the following arguments:
   *
   * - item - the menu item record being rendered.
   *
   * Return null to render the default contents
   *
   * Example:
   *
   * ```js
   *  renderItemContent={item => {
   *    return leaf ? <ListItemText primary={item.text}/> : null
   *  }}
   * ```
   */
  renderItemContent: _propTypes["default"].func,

  /**
   * Set to `true` to show the item corresponding to the current URL as selected.
   */
  trackSelected: _propTypes["default"].bool,

  /**
   * A function to override the rendering the drawer
   */
  renderDrawer: _propTypes["default"].func
};
Menu.defaultProps = {
  drawerWidth: 330,
  anchor: 'left',
  trackSelected: false,
  DrawerComponent: _Drawer["default"]
};
var _default = Menu;
exports["default"] = _default;
//# sourceMappingURL=Menu.js.map