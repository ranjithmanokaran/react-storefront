"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = Image;
exports.styles = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _clsx3 = _interopRequireDefault(require("clsx"));

var _reactVisibilitySensor = _interopRequireDefault(require("react-visibility-sensor"));

var _styles = require("@material-ui/core/styles");

var _PWAContext = _interopRequireDefault(require("./PWAContext"));

var styles = function styles(theme) {
  return {
    /**
     * Styles applied to the root element.
     */
    root: {
      position: 'relative',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      // Without a minimum height and width, the container will not fire
      // the visibility change
      minHeight: 1,
      minWidth: 1
    },

    /**
     * Styles applied to the image element.
     */
    image: {},

    /**
     * Styles applied to the image element when [`aspectRatio`](#prop-aspectRatio) is defined.
     */
    fit: {
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      display: 'block',
      width: '100%',
      height: '100%'
    },

    /**
     * Styles applied to the root element when [`contain`](#prop-contain) is `true`.
     */
    contain: {
      '& img': {
        objectFit: 'contain',
        maxHeight: '100%',
        maxWidth: '100%'
      }
    },

    /**
     * Styles applied to the root element when [`fill`](#prop-fill) is `true`.
     */
    fill: {
      width: '100%',
      height: '100%',
      '& img': {
        display: 'block',
        objectFit: 'contain',
        maxHeight: '100%',
        maxWidth: '100%',
        width: '100%',
        height: '100%'
      }
    }
  };
};

exports.styles = styles;
var useStyles = (0, _styles.makeStyles)(styles, {
  name: 'RSFImage'
});
/**
 * Displays an image that can be lazy loaded and made to auto-scale to fit the parent element
 * by setting the `fill` prop, or grow/shrink while maintaining a given aspect ratio
 * by setting the `aspectRatio` prop.
 */

function Image(_ref) {
  var _clsx, _clsx2;

  var lazy = _ref.lazy,
      lazyOffset = _ref.lazyOffset,
      notFoundSrc = _ref.notFoundSrc,
      height = _ref.height,
      width = _ref.width,
      fill = _ref.fill,
      bind = _ref.bind,
      contain = _ref.contain,
      classes = _ref.classes,
      className = _ref.className,
      aspectRatio = _ref.aspectRatio,
      alt = _ref.alt,
      src = _ref.src,
      amp = _ref.amp,
      optimize = _ref.optimize,
      onChange = _ref.onChange,
      onSrcChange = _ref.onSrcChange,
      onAltChange = _ref.onAltChange,
      value = _ref.value,
      ImgElement = _ref.ImgElement,
      imgAttributes = (0, _objectWithoutProperties2["default"])(_ref, ["lazy", "lazyOffset", "notFoundSrc", "height", "width", "fill", "bind", "contain", "classes", "className", "aspectRatio", "alt", "src", "amp", "optimize", "onChange", "onSrcChange", "onAltChange", "value", "ImgElement"]);

  function lazyLoad(visible) {
    if (!loaded && visible) {
      setLoaded(true);
    }
  }

  classes = useStyles({
    classes: classes
  });

  var _ref2 = (0, _react.useContext)(_PWAContext["default"]) || {},
      hydrating = _ref2.hydrating;

  var _useState = (0, _react.useState)(lazy === false || lazy === 'ssr' && !hydrating),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      loaded = _useState2[0],
      setLoaded = _useState2[1];

  var _useState3 = (0, _react.useState)(false),
      _useState4 = (0, _slicedToArray2["default"])(_useState3, 2),
      primaryNotFound = _useState4[0],
      setPrimaryNotFound = _useState4[1];

  var ref = (0, _react.useRef)();
  (0, _react.useEffect)(function () {
    var img = ref.current;

    if (img && img.complete && img.naturalWidth === 0) {
      setPrimaryNotFound(true);
    }
  }, []);
  if (src == null) return null;
  contain = contain || aspectRatio;

  if (primaryNotFound && notFoundSrc) {
    src = notFoundSrc;
  }

  var result = /*#__PURE__*/_react["default"].createElement("div", {
    className: (0, _clsx3["default"])(className, (_clsx = {}, (0, _defineProperty2["default"])(_clsx, classes.root, true), (0, _defineProperty2["default"])(_clsx, classes.contain, contain), (0, _defineProperty2["default"])(_clsx, classes.fill, fill), _clsx))
  }, aspectRatio && /*#__PURE__*/_react["default"].createElement("div", {
    style: {
      paddingTop: "".concat(aspectRatio * 100, "%")
    }
  }), loaded && /*#__PURE__*/_react["default"].createElement(ImgElement, (0, _extends2["default"])({
    ref: ref,
    src: src,
    key: src,
    height: height,
    width: width,
    alt: alt,
    className: (0, _clsx3["default"])((_clsx2 = {}, (0, _defineProperty2["default"])(_clsx2, classes.image, true), (0, _defineProperty2["default"])(_clsx2, classes.fit, aspectRatio != null), _clsx2))
  }, imgAttributes, {
    // prevent render "onerror" as a DOM prop in case of amp-img tag
    onError: ImgElement !== 'amp-img' ? function () {
      return setPrimaryNotFound(true);
    } :
    /* istanbul ignore next */
    undefined
  })));

  result = /*#__PURE__*/_react["default"].createElement(_reactVisibilitySensor["default"], {
    active: !loaded,
    onChange: lazyLoad,
    partialVisibility: true,
    offset: {
      top: -lazyOffset,
      bottom: -lazyOffset
    }
  }, result);
  return result;
}

Image.propTypes = {
  /**
   * The URL for the image.
   */
  src: _propTypes["default"].string,

  /**
   * The URL of the image to use in case the primary image fails to load.
   */
  notFoundSrc: _propTypes["default"].string,

  /**
   * The ratio of height/width as a float.  For example: `1` when the height and width match,
   * `0.5` when height is half of the width.
   */
  aspectRatio: _propTypes["default"].number,

  /**
   * Set to `true` to apply object-fit:contain to the image so that it automatically
   * fits within the element's height and width.
   */
  contain: _propTypes["default"].bool,

  /**
   * The same as `contain`, except images are stretched to fill the element's height and width.
   */
  fill: _propTypes["default"].bool,

  /**
   * Set to `true` to wait until the image enters the viewport before loading it. Set to `"ssr"` to
   * only lazy load images during server side rendering.
   */
  lazy: _propTypes["default"].oneOf(['ssr', true, false]),

  /**
   * Sets the minimum amount of pixels the image can be scrolled out of view before it
   * is lazy loaded.  You must set `lazy` in order for this setting to take effect.
   */
  lazyOffset: _propTypes["default"].number
};
Image.defaultProps = {
  contain: false,
  fill: false,
  lazy: false,
  lazyOffset: 100,
  ImgElement: 'img'
};
//# sourceMappingURL=Image.js.map