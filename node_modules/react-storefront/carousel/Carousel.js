"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.AutoPlayVirtualizeSwipeableViews = exports.VirtualizeSwipeableViews = exports.AutoPlaySwipeableViews = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _clsx = _interopRequireDefault(require("clsx"));

var _styles = require("@material-ui/core/styles");

var _reactSwipeableViews = _interopRequireDefault(require("react-swipeable-views"));

var _reactSwipeableViewsUtils = require("react-swipeable-views-utils");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _CarouselDots = _interopRequireDefault(require("./CarouselDots"));

var _CarouselArrows = _interopRequireDefault(require("./CarouselArrows"));

var _mod = _interopRequireDefault(require("../utils/mod"));

var _Fill = _interopRequireDefault(require("../Fill"));

var styles = function styles(theme) {
  return {
    /**
     * Styles applied to the root element.
     */
    root: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'stretch',
      position: 'relative',
      flexBasis: '100%',
      '& img': {
        display: 'block'
      }
    },

    /**
     * Styles applied to wrapper element of the swipe container.
     */
    swipeWrap: {
      position: 'relative',
      overflow: 'hidden',
      flex: 1,
      height: '100%',
      '& .react-swipeable-view-container, & .react-swipeable-view-container > div': {
        height: '100%'
      }
    },
    autoPlaySwipeableViews: {
      overflowY: 'hidden',
      height: '100%'
    },
    '@media not all and (hover:none)': {
      hideTouchArrows: {
        display: 'none'
      }
    }
  };
};

var useStyles = (0, _styles.makeStyles)(styles, {
  name: 'RSFCarousel'
});
var AutoPlaySwipeableViews = (0, _reactSwipeableViewsUtils.autoPlay)(_reactSwipeableViews["default"]);
exports.AutoPlaySwipeableViews = AutoPlaySwipeableViews;
var VirtualizeSwipeableViews = (0, _reactSwipeableViewsUtils.virtualize)(_reactSwipeableViews["default"]);
exports.VirtualizeSwipeableViews = VirtualizeSwipeableViews;
var AutoPlayVirtualizeSwipeableViews = (0, _reactSwipeableViewsUtils.autoPlay)(VirtualizeSwipeableViews);
exports.AutoPlayVirtualizeSwipeableViews = AutoPlayVirtualizeSwipeableViews;

function useSelected(props) {
  if (props.setSelected) {
    return props;
  } else {
    var _useState = (0, _react.useState)(0),
        _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
        selected = _useState2[0],
        setSelected = _useState2[1];

    return {
      selected: selected,
      setSelected: setSelected
    };
  }
}
/**
 * A grouped display of elements that shows one element at a time, and changes to peer elements by
 * swiping to the left or right, or by clicking arrows on the sides of the component. Generally used
 * as a non-Amp option for the [`CarouselComponent`](/apiReference/carousel/MediaCarousel#prop-CarouselComponent)
 * prop within a [`MediaCarousel`](/apiReference/carousel/MediaCarousel).
 */


var Carousel = /*#__PURE__*/_react["default"].forwardRef(function (props, ref) {
  var height = props.height,
      children = props.children,
      classes = props.classes,
      className = props.className,
      style = props.style,
      swipeStyle = props.swipeStyle,
      slideStyle = props.slideStyle,
      arrows = props.arrows,
      aboveAdornments = props.aboveAdornments,
      belowAdornments = props.belowAdornments,
      onMouseEnter = props.onMouseEnter,
      onMouseLeave = props.onMouseLeave,
      onClick = props.onClick,
      indicators = props.indicators,
      autoplay = props.autoplay,
      interval = props.interval,
      infinite = props.infinite;
  classes = useStyles({
    classes: classes
  });

  var _useSelected = useSelected(props),
      selected = _useSelected.selected,
      setSelected = _useSelected.setSelected;

  var count = children && children.length;
  var Tag = infinite ? VirtualizeSwipeableViews : _reactSwipeableViews["default"];
  Tag = autoplay ? AutoPlaySwipeableViews : Tag;
  Tag = infinite && autoplay ? AutoPlayVirtualizeSwipeableViews : Tag;

  var slideRenderer = function slideRenderer(_ref) {
    var index = _ref.index;
    var key = "slide-renderer-".concat(index);
    var child = children[(0, _mod["default"])(index, count)];
    if (!child) return null;

    var slide = /*#__PURE__*/_react["default"].cloneElement(child);

    return /*#__PURE__*/_react["default"].createElement(_react.Fragment, {
      key: key
    }, slide);
  };

  var onChangeIndex = (0, _react.useCallback)(function (index) {
    if (!infinite) {
      setSelected(index);
      return;
    } // carousel loop-around calculations


    var nextSelectedIndex = index;

    if (nextSelectedIndex + 1 > count) {
      nextSelectedIndex = 0;
    } else if (nextSelectedIndex < 0) {
      nextSelectedIndex = count - 1;
    }

    setSelected(nextSelectedIndex);
  }, [infinite, count, selected, setSelected]);
  return /*#__PURE__*/_react["default"].createElement("div", {
    ref: ref,
    className: (0, _clsx["default"])(className, classes.root),
    style: style,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onClick: onClick
  }, aboveAdornments, /*#__PURE__*/_react["default"].createElement(_Fill["default"], {
    height: height
  }, /*#__PURE__*/_react["default"].createElement("div", {
    className: classes.swipeWrap
  }, /*#__PURE__*/_react["default"].createElement(Tag, {
    index: selected,
    onChangeIndex: onChangeIndex,
    className: classes.autoPlaySwipeableViews,
    style: swipeStyle,
    slideStyle: slideStyle,
    slideRenderer: props.slideRenderer || slideRenderer,
    interval: interval,
    containerStyle: {
      alignItems: 'center'
    }
  }), arrows !== false && /*#__PURE__*/_react["default"].createElement(_CarouselArrows["default"], {
    className: arrows === 'desktop' ? classes.hideTouchArrows : null,
    selected: selected,
    setSelected: setSelected,
    count: count,
    infinite: infinite
  }), indicators && /*#__PURE__*/_react["default"].createElement(_CarouselDots["default"], {
    count: count,
    selected: selected
  }))), belowAdornments);
});

Carousel.propTypes = {
  /**
   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.
   */
  classes: _propTypes["default"].object,

  /**
   * Set to `false` to hide arrows, `'desktop'` to only show them
   * on non-touch devices, `'all'` to always show arrows.
   */
  arrows: _propTypes["default"].oneOf([false, 'desktop', 'all']),

  /**
   * Nodes to render above the Carousel.
   */
  aboveAdornments: _propTypes["default"].arrayOf(_propTypes["default"].element),

  /**
   * Nodes to render below the Carousel.
   */
  belowAdornments: _propTypes["default"].arrayOf(_propTypes["default"].element),

  /**
   * If `true`, the Carousel will automatically cycle through the media elements.
   */
  autoplay: _propTypes["default"].bool,

  /**
   * If true, scrolling past the last slide will cycle back to the first
   */
  infinite: _propTypes["default"].bool,

  /**
   * The interval time (in milliseconds) for [`autoplay`](#prop-autoplay).
   */
  interval: _propTypes["default"].number
};
Carousel.defaultProps = {
  indicators: true,
  arrows: 'desktop',
  autoplay: false,
  interval: 3000,
  infinite: true
};
var _default = Carousel;
exports["default"] = _default;
//# sourceMappingURL=Carousel.js.map