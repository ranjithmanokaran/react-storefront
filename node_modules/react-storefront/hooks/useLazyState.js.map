{"version":3,"sources":["../../src/hooks/useLazyState.js"],"names":["useLazyState","lazyProps","additionalData","isInitialMount","Router","linkPageData","LinkContext","undefined","createInitialState","pageData","props","loading","lazy","url","goingBack","state","setState","stateRef","updateState","finalState","current","then","process","env","NODE_ENV","window","rsf_toggleLoading","onHistoryChange","recordState","beforePopState","events","on","resetGoingBack","off","as","location","pathname","search","hash","historyState","history","rsf","replaceState","document","title"],"mappings":"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","sourcesContent":["import { useEffect, useRef, useState, useContext, useCallback } from 'react'\nimport { useRouter } from 'next/router'\nimport merge from '../utils/merge'\nimport LinkContext from '../link/LinkContext'\nimport get from 'lodash/get'\nimport storeInitialPropsInHistory from '../router/storeInitialPropsInHistory'\n\nstoreInitialPropsInHistory()\n\nexport default function useLazyState(lazyProps, additionalData = {}) {\n  const isInitialMount = useRef(true)\n  const Router = useRouter()\n\n  // If linkPageData is null then lodash merge will overwrite everything in additionalData.pageData\n  // It will properly merge the values if linkPageData is undefined\n  const linkPageData = get(useContext(LinkContext), 'current') || undefined\n\n  const createInitialState = () => {\n    return merge({}, additionalData, { pageData: linkPageData }, props, {\n      loading: lazyProps.lazy != null,\n      pageData: {},\n    })\n  }\n\n  const { lazy, url, ...props } = lazyProps\n  const goingBack = useRef(false)\n  const [state, setState] = useState(createInitialState)\n  const stateRef = useRef(state)\n\n  const updateState = finalState => {\n    if (typeof finalState !== 'function') {\n      stateRef.current = finalState\n\n      return setState(finalState)\n    } else {\n      return setState(state => {\n        stateRef.current = finalState(state)\n\n        return stateRef.current\n      })\n    }\n  }\n\n  useEffect(() => {\n    if (stateRef.current.loading && !isInitialMount.current) {\n      return\n    }\n\n    if (lazyProps.lazy) {\n      updateState(state => ({ ...state, loading: true }))\n\n      lazy.then(props =>\n        updateState(\n          merge({}, additionalData, { pageData: linkPageData }, props, { loading: false }),\n        ),\n      )\n    } else {\n      if (!isInitialMount.current) {\n        // there is no need to do this if we just mounted since createInitialState will return the same thing as the current state\n        updateState(createInitialState())\n      }\n    }\n  }, [lazyProps])\n\n  useEffect(() => {\n    isInitialMount.current = false\n\n    if (process.env.NODE_ENV !== 'production') {\n      // expose a global function that makes it easy to toggle skeletons during development via chrome develeoper console\n      window.rsf_toggleLoading = () =>\n        updateState(state => ({\n          ...state,\n          loading: !state.loading,\n        }))\n\n      return () => delete window.rsf_toggleLoading\n    }\n  }, [])\n\n  // save the page state in history.state before navigation\n  const onHistoryChange = useCallback(() => {\n    if (!goingBack.current && !stateRef.current.loading) {\n      // We don't record pageData in history here because the browser has already changed the\n      // URL to the previous page.  It's too late.  This means that going forward will always result\n      // in a fetch (though usually this will just come from the browser's cache)\n\n      recordState(stateRef.current.pageData)\n    }\n  }, [recordState])\n\n  useEffect(() => {\n    Router.beforePopState(() => {\n      goingBack.current = true\n      return true\n    })\n\n    Router.events.on('routeChangeStart', onHistoryChange)\n    Router.events.on('routeChangeComplete', resetGoingBack)\n\n    return () => {\n      Router.events.off('routeChangeStart', onHistoryChange)\n      Router.events.off('routeChangeComplete', resetGoingBack)\n    }\n  }, [])\n\n  const resetGoingBack = useCallback(() => {\n    goingBack.current = false\n  }, [])\n\n  return [state, updateState]\n}\n\n/**\n * Records the page state in history.state.rsf[uri].  Why is this needed?  Why can we not\n * simply rely on the page data being in the browser's cache via the service worker? It's\n * because we want to restore the state of the page as the user left it, including sorting,\n * paging, and any other changes which might not be reflected in the URL.\n * @param {Object} state The page state\n */\nfunction recordState(state) {\n  const as = location.pathname + location.search + location.hash\n  const historyState = { ...history.state, as, rsf: { [as]: state } }\n\n  history.replaceState(historyState, document.title, as)\n}\n"],"file":"useLazyState.js"}