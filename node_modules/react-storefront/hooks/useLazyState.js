"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = useLazyState;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = require("react");

var _router = require("next/router");

var _merge = _interopRequireDefault(require("../utils/merge"));

var _LinkContext = _interopRequireDefault(require("../link/LinkContext"));

var _get = _interopRequireDefault(require("lodash/get"));

var _storeInitialPropsInHistory = _interopRequireDefault(require("../router/storeInitialPropsInHistory"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

(0, _storeInitialPropsInHistory["default"])();

function useLazyState(lazyProps) {
  var additionalData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var isInitialMount = (0, _react.useRef)(true);
  var Router = (0, _router.useRouter)(); // If linkPageData is null then lodash merge will overwrite everything in additionalData.pageData
  // It will properly merge the values if linkPageData is undefined

  var linkPageData = (0, _get["default"])((0, _react.useContext)(_LinkContext["default"]), 'current') || undefined;

  var createInitialState = function createInitialState() {
    return (0, _merge["default"])({}, additionalData, {
      pageData: linkPageData
    }, props, {
      loading: lazyProps.lazy != null,
      pageData: {}
    });
  };

  var lazy = lazyProps.lazy,
      url = lazyProps.url,
      props = (0, _objectWithoutProperties2["default"])(lazyProps, ["lazy", "url"]);
  var goingBack = (0, _react.useRef)(false);

  var _useState = (0, _react.useState)(createInitialState),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  var stateRef = (0, _react.useRef)(state);

  var updateState = function updateState(finalState) {
    if (typeof finalState !== 'function') {
      stateRef.current = finalState;
      return setState(finalState);
    } else {
      return setState(function (state) {
        stateRef.current = finalState(state);
        return stateRef.current;
      });
    }
  };

  (0, _react.useEffect)(function () {
    if (stateRef.current.loading && !isInitialMount.current) {
      return;
    }

    if (lazyProps.lazy) {
      updateState(function (state) {
        return _objectSpread(_objectSpread({}, state), {}, {
          loading: true
        });
      });
      lazy.then(function (props) {
        return updateState((0, _merge["default"])({}, additionalData, {
          pageData: linkPageData
        }, props, {
          loading: false
        }));
      });
    } else {
      if (!isInitialMount.current) {
        // there is no need to do this if we just mounted since createInitialState will return the same thing as the current state
        updateState(createInitialState());
      }
    }
  }, [lazyProps]);
  (0, _react.useEffect)(function () {
    isInitialMount.current = false;

    if (process.env.NODE_ENV !== 'production') {
      // expose a global function that makes it easy to toggle skeletons during development via chrome develeoper console
      window.rsf_toggleLoading = function () {
        return updateState(function (state) {
          return _objectSpread(_objectSpread({}, state), {}, {
            loading: !state.loading
          });
        });
      };

      return function () {
        return delete window.rsf_toggleLoading;
      };
    }
  }, []); // save the page state in history.state before navigation

  var onHistoryChange = (0, _react.useCallback)(function () {
    if (!goingBack.current && !stateRef.current.loading) {
      // We don't record pageData in history here because the browser has already changed the
      // URL to the previous page.  It's too late.  This means that going forward will always result
      // in a fetch (though usually this will just come from the browser's cache)
      recordState(stateRef.current.pageData);
    }
  }, [recordState]);
  (0, _react.useEffect)(function () {
    Router.beforePopState(function () {
      goingBack.current = true;
      return true;
    });
    Router.events.on('routeChangeStart', onHistoryChange);
    Router.events.on('routeChangeComplete', resetGoingBack);
    return function () {
      Router.events.off('routeChangeStart', onHistoryChange);
      Router.events.off('routeChangeComplete', resetGoingBack);
    };
  }, []);
  var resetGoingBack = (0, _react.useCallback)(function () {
    goingBack.current = false;
  }, []);
  return [state, updateState];
}
/**
 * Records the page state in history.state.rsf[uri].  Why is this needed?  Why can we not
 * simply rely on the page data being in the browser's cache via the service worker? It's
 * because we want to restore the state of the page as the user left it, including sorting,
 * paging, and any other changes which might not be reflected in the URL.
 * @param {Object} state The page state
 */


function recordState(state) {
  var as = location.pathname + location.search + location.hash;

  var historyState = _objectSpread(_objectSpread({}, history.state), {}, {
    as: as,
    rsf: (0, _defineProperty2["default"])({}, as, state)
  });

  history.replaceState(historyState, document.title, as);
}
//# sourceMappingURL=useLazyState.js.map