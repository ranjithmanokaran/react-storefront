"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitForServiceWorker = waitForServiceWorker;
exports.prefetch = prefetch;
exports.prefetchJsonFor = prefetchJsonFor;
exports.resetPrefetches = resetPrefetches;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _getAPIURL = _interopRequireDefault(require("./api/getAPIURL"));

var _addVersion = _interopRequireDefault(require("./api/addVersion"));

var prefetched = new Set();
/**
 * Resolves when the service worker has been installed.
 * @private
 */

function waitForServiceWorker() {
  if (!navigator.serviceWorker || !navigator.serviceWorker.ready) {
    return false;
  }

  return new Promise(function (resolve) {
    navigator.serviceWorker.ready.then(function () {
      if (navigator.serviceWorker.controller) {
        return resolve(true);
      }

      navigator.serviceWorker.addEventListener('controllerchange', function () {
        return resolve(true);
      });
    });
  });
}
/**
 * Prefetches the specified URL. This function will wait for the service worker
 * to be installed to ensure that it has the opportunity to cache the response.
 * @param {String} url The URL to prefetch
 */


function prefetch(_x) {
  return _prefetch.apply(this, arguments);
}
/**
 * Prefetches the JSON API results for a given page
 * @param {String} url The page URL.
 */


function _prefetch() {
  _prefetch = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(url) {
    var link, relList, rel;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(url == null)) {
              _context.next = 2;
              break;
            }

            return _context.abrupt("return");

          case 2:
            if (!(process.env.NODE_ENV !== 'production' && process.env.SERVICE_WORKER !== 'true')) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return");

          case 4:
            url = (0, _addVersion["default"])(url).toString();

            if (!prefetched.has(url)) {
              _context.next = 7;
              break;
            }

            return _context.abrupt("return");

          case 7:
            prefetched.add(url);
            _context.next = 10;
            return waitForServiceWorker();

          case 10:
            link = document.createElement('link');
            relList = link.relList;
            rel = relList.supports('preload') &&
            /* istanbul ignore next */
            !relList.supports('prefetch') ?
            /* istanbul ignore next */
            'preload' : 'prefetch'; // Safari does not support prefetch so we use preload instead

            link.setAttribute('href', addPrefetchParam(url));
            link.setAttribute('as', 'fetch');
            link.setAttribute('rel', rel);
            document.head.append(link);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _prefetch.apply(this, arguments);
}

function prefetchJsonFor(url) {
  return prefetch((0, _getAPIURL["default"])(url));
}
/**
 * Adds process.env.PREFETCH_QUERY_PARAM to the URL so that back ends can identify prefetch requests and
 * potentially ignore them during periods of high traffic.
 * @param {String} url
 * @return {String} A new URL
 */


function addPrefetchParam(url) {
  var prefetchQueryParam = process.env.RSF_PREFETCH_QUERY_PARAM;

  if (prefetchQueryParam) {
    var parsed = new URL(url, location.href);

    if (parsed.hostname === location.hostname) {
      // only add __prefetch__ for requests going back to Layer0.
      parsed.searchParams.append(prefetchQueryParam, '1');
    }

    return parsed.toString();
  } else {
    return url;
  }
}
/**
 * Clears the set which keeps track of which URLs have been prefetched so
 * they can be prefetched again.
 */


function resetPrefetches() {
  prefetched.clear();
}
//# sourceMappingURL=serviceWorker.js.map