"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = Lazy;
exports.styles = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _reactVisibilitySensor = _interopRequireDefault(require("react-visibility-sensor"));

var _clsx = _interopRequireDefault(require("clsx"));

var _styles = require("@material-ui/core/styles");

var _PWAContext = _interopRequireDefault(require("./PWAContext"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _amp = require("next/amp");

var styles = function styles() {
  return {
    /**
     * Styles applied to the root element.
     */
    root: {
      minHeight: 1,
      minWidth: 1
    }
  };
};

exports.styles = styles;
var useStyles = (0, _styles.makeStyles)(styles, {
  name: 'RSFLazy'
});
/**
 * Defers the rendering of children until the component is visible in the viewport. When
 * using Lazy we recommend assigning a CSS class that defines minHeight and minWidth to prevent
 * layout instability when children are lazy loaded.
 *
 * You can use `<Lazy ssrOnly>` to only implement lazy behavior during server side rendering.
 *
 * Example:
 *
 * ```js
 * <Lazy style={{ minHeight: 200 }}>
 *   <SomeExpensiveComponent/>
 * </Lazy>
 * ```
 */

function Lazy(_ref) {
  var ssrOnly = _ref.ssrOnly,
      className = _ref.className,
      classes = _ref.classes,
      children = _ref.children,
      otherProps = (0, _objectWithoutProperties2["default"])(_ref, ["ssrOnly", "className", "classes", "children"]);
  var amp = (0, _amp.useAmp)();

  var _useContext = (0, _react.useContext)(_PWAContext["default"]),
      hydrating = _useContext.hydrating;

  var _useState = (0, _react.useState)(amp || ssrOnly && !hydrating),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      visible = _useState2[0],
      setVisible = _useState2[1];

  classes = useStyles({
    classes: classes
  });

  function onChange(v) {
    if (!visible && v) {
      setVisible(true);
    }
  }

  return /*#__PURE__*/_react["default"].createElement(_reactVisibilitySensor["default"], {
    onChange: onChange,
    active: !visible,
    partialVisibility: true
  }, /*#__PURE__*/_react["default"].createElement("div", (0, _extends2["default"])({
    className: (0, _clsx["default"])(classes.root, className)
  }, otherProps), visible && children));
}

Lazy.propTypes = {
  /**
   * Override or extend the styles applied to the component. See [CSS API](#css) below for more details.
   */
  classes: _propTypes["default"].object,

  /**
   * CSS class to apply to the root element
   */
  className: _propTypes["default"].string,

  /**
   * Set to `true` to render children immediately when this component is mounted after initial hydration.
   */
  ssrOnly: _propTypes["default"].bool
};
Lazy.defaultProps = {
  ssrOnly: false
};
//# sourceMappingURL=Lazy.js.map