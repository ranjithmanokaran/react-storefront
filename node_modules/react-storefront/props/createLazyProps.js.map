{"version":3,"sources":["../../src/props/createLazyProps.js"],"names":["createLazyProps","fetchCallback","timeout","options","window","rsf","history","state","asPath","pageData","Promise","resolve","reject","fetchPromise","setTimeout","lazy","then","result","e"],"mappings":";;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmDe,SAASA,eAAT,CAAyBC,aAAzB,EAAgE;AAAA,iFAAJ,EAAI;AAAA,0BAAtBC,OAAsB;AAAA,MAAtBA,OAAsB,6BAAZ,GAAY;;AAC7E,SAAO,UAACC;AAAQ;AAAT,IAAwC;AAC7C,QAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;AACjC;AACA,aAAOH,aAAa,CAACE,OAAD,CAApB;AACD,KAHD,MAGO;AACL;AADK,UAEGE,GAFH,GAEWD,MAAM,CAACE,OAAP,CAAeC,KAF1B,CAEGF,GAFH;;AAIL,UAAIA,GAAG,IAAIA,GAAG,CAACF,OAAO,CAACK,MAAT,CAAd,EAAgC;AAC9B;;AACA;AACA,eAAO;AACLC,UAAAA,QAAQ,EAAEJ,GAAG,CAACF,OAAO,CAACK,MAAT;AADR,SAAP;AAGD,OAND,MAMO;AACL,eAAO,IAAIE,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,cAAMC,YAAY,GAAGZ,aAAa,CAACE,OAAD,CAAlC;AAEAW,UAAAA,UAAU,CAAC,YAAM;AACfH,YAAAA,OAAO,CAAC;AAAEI,cAAAA,IAAI,EAAEF;AAAR,aAAD,CAAP;AACD,WAFS,EAEPX,OAFO,CAAV;AAIAW,UAAAA,YAAY,CACTG,IADH,CACQ,UAAAC,MAAM,EAAI;AACdN,YAAAA,OAAO,CAACM,MAAD,CAAP;AACD,WAHH,WAIS,UAAAC,CAAC,EAAI;AACVN,YAAAA,MAAM,CAACM,CAAD,CAAN;AACD,WANH;AAOD,SAdM,CAAP;AAeD;AACF;AACF,GAhCD;AAiCD","sourcesContent":["/**\n * Creates a function for next's `getInitialProps` that returns \"lazy\" props after a maximum `timeout` that\n * defaults to 50ms. This function should be used in conjunction with `hooks/useLazyState` in the component\n * to display a skeleton until page data is returned from the network.\n *\n * During client-side navigation, this allows the page component to render before the fetched data is returned from the server.\n * This gives us an opportunity to display a skeleton when the network is slow.  On a fast network or when the response is\n * cached in the browser, and thus returns within the configured timeout, the fetched data will be available for the page's\n * initial render, and we can skip the skeleton.\n *\n * When rendering on the server, the timeout is not enforced.  This function simply waits for the network and returns\n * once data is received.\n *\n * Example:\n *\n * ```js\n * import useLazyState from 'react-storefront/hooks/useLazyState'\n * import fetchFromAPI from 'react-storefront/props/fetchFromAPI'\n *\n * function Product(lazyProps) {\n *   const [state, updateState] = useLazyState(lazyProps)\n *   const { product } = state.pageData\n *\n *   // state.loading will be true while fetching product data from the server\n *\n *   // state.pageData will be populated with the `pageData` prop provided to the <Link> element\n *   // that was clicked.  In this way you can provide partial data to a page.  For example:\n *   //\n *   // <Link href=\"/p/[productId]\" as={`/p/${product.id}`} pageData={{ product }}>{product.name}</Link>\n *\n *   return (\n *     <Grid container spacing={4}>\n *       <Grid item xs={12}>\n *         { product.name ? <Typography variant=\"h1\">{product.name}</Typography> : <Skeleton style={{ height: 16 }}/> }\n *       </Grid>\n *       // render the rest of the PDP\n *     </Grid>\n *   )\n * }\n *\n * Product.getInitialProps = createLazyProps(opts => {\n *   return fetchFromAPI(opts)\n * }, { timeout: 50 })\n * ```\n *\n * @param {Function} fetchCallback A function to use to create the URL\n * @param {Object} options\n * @param {Object} options.timeout The max duration to wait before resolving so that the page\n *  component will be rendered and can display a skeleton while waiting for the promise returned\n *  by `fetchCallback` to resolve\n */\nexport default function createLazyProps(fetchCallback, { timeout = 100 } = {}) {\n  return (options /* from getInitialProps */) => {\n    if (typeof window === 'undefined') {\n      // server\n      return fetchCallback(options)\n    } else {\n      // client\n      const { rsf } = window.history.state\n\n      if (rsf && rsf[options.asPath]) {\n        // going back or forward\n        /* this is written useLazyState's recordState function when the user navigates (not back) */\n        return {\n          pageData: rsf[options.asPath],\n        }\n      } else {\n        return new Promise((resolve, reject) => {\n          const fetchPromise = fetchCallback(options)\n\n          setTimeout(() => {\n            resolve({ lazy: fetchPromise })\n          }, timeout)\n\n          fetchPromise\n            .then(result => {\n              resolve(result)\n            })\n            .catch(e => {\n              reject(e)\n            })\n        })\n      }\n    }\n  }\n}\n"],"file":"createLazyProps.js"}