{"version":3,"sources":["../../src/utils/fetchLatest.js"],"names":["fetchLatest","fetch","nextId","controller","abort","AbortController","signal","url","options","id","then","response","StaleResponseError","error","name","Error","e"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAuBO,SAASA,WAAT,CAAqBC,KAArB,EAA4B;AACjC,MAAIC,MAAM,GAAG,CAAb;AACA,MAAIC,UAAJ;;AAEA,MAAMC,KAAK,GAAG,SAARA,KAAQ,GAAM;AAClBD,IAAAA,UAAU,IAAIA,UAAU,CAACC,KAAX,EAAd;;AAEA,QAAI,OAAOC,eAAP,KAA2B,WAA/B,EAA4C;AAC1C,aAAQF,UAAU,GAAG,IAAIE,eAAJ,EAArB;AACD,KAFD,MAEO;AACL,aAAO;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;AACF,GARD;;AAUA,SAAO,UAACC,GAAD,EAAMC,OAAN,EAAkB;AACvB,QAAIC,EAAE,GAAG,EAAEP,MAAX;AACA,QAAMI,MAAM,GAAGF,KAAK,GAAGE,MAAvB;AAEA,WAAOL,KAAK,CAACM,GAAD,kCAAWC,OAAX;AAAoBF,MAAAA,MAAM,EAANA;AAApB,OAAL,CACJI,IADI,CACC,UAAAC,QAAQ,EAAI;AAChB,UAAIF,EAAE,KAAKP,MAAX,EAAmB;AACjB,cAAM,IAAIU,kBAAJ,EAAN;AACD;;AACD,aAAOD,QAAP;AACD,KANI,WAOE,UAAAE,KAAK,EAAI;AACd;AACA;AACA,UAAIA,KAAK,CAACC,IAAN,KAAe,YAAnB,EAAiC;AAC/B,cAAM,IAAIF,kBAAJ,EAAN;AACD,OAFD,MAEO;AACL,cAAMC,KAAN;AACD;AACF,KAfI,CAAP;AAgBD,GApBD;AAqBD;AAED;;;;;IAGaD,kB;;;;;;;;;;;;;;;6FACJ,oB;;;;;kDAD+BG,K;;;iCAA3BH,kB,QAMC,UAAAI,CAAC;AAAA,SAAIA,CAAC,CAACF,IAAF,KAAW,oBAAf;AAAA,C","sourcesContent":["/**\n * Creates a fetch function with an internal incrementing request counter that ensures that out of order\n * responses result in a `StaleResponseError`.\n *\n * Example usage:\n *\n * ```js\n * import { fetchLatest, StaleResponseError } from 'react-storefront/fetchLatest'\n * import originalFetch from 'fetch'\n *\n * const fetch = fetchLatest(originalFetch)\n *\n * try {\n *   const response = await fetch('/some/url')\n * } catch (e) {\n *   if (!StaleResponseError.is(e)) {\n *     throw e // just ignore stale responses, rethrow all other errors\n *   }\n * }\n * ```\n * @param {Function} fetch An implementation of the standard browser fetch.\n * @return {Function}\n */\nexport function fetchLatest(fetch) {\n  let nextId = 0\n  let controller\n\n  const abort = () => {\n    controller && controller.abort()\n\n    if (typeof AbortController !== 'undefined') {\n      return (controller = new AbortController())\n    } else {\n      return { signal: null }\n    }\n  }\n\n  return (url, options) => {\n    let id = ++nextId\n    const signal = abort().signal\n\n    return fetch(url, { ...options, signal })\n      .then(response => {\n        if (id !== nextId) {\n          throw new StaleResponseError()\n        }\n        return response\n      })\n      .catch(error => {\n        // For browsers that support AbortController, ensure that the behavior is the same as browsers that don't -\n        // StaleResponseError should be thrown in either case\n        if (error.name === 'AbortError') {\n          throw new StaleResponseError()\n        } else {\n          throw error\n        }\n      })\n  }\n}\n\n/**\n * Thrown when an out of order response is received from `fetchLatest`.\n */\nexport class StaleResponseError extends Error {\n  name = 'StaleResponseError'\n\n  /**\n   * Returns true if the specified Error is an instance of StaleResponseError\n   */\n  static is = e => e.name === 'StaleResponseError'\n}\n"],"file":"fetchLatest.js"}