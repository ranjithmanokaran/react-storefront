"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = ResponsiveTiles;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _GridListTile = _interopRequireDefault(require("@material-ui/core/GridListTile"));

var _styles = require("@material-ui/core/styles");

var _clsx = _interopRequireDefault(require("clsx"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _AutoScrollToNewChildren = _interopRequireDefault(require("./AutoScrollToNewChildren"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * A responsive grid of tiles that changes the number of columns based on the viewport size.
 * This component commonly used in product listings and search results.
 */
function ResponsiveTiles(props) {
  var Tiles = (0, _react.useRef)(createTiles(props));
  var cols = props.cols,
      spacing = props.spacing,
      others = (0, _objectWithoutProperties2["default"])(props, ["cols", "spacing"]);
  return /*#__PURE__*/_react["default"].createElement(Tiles.current, others);
}

ResponsiveTiles.propTypes = {
  /**
   * If `true`, automatically scroll to the first new tile when the
   * number of tiles is increased.
   */
  autoScrollToNewTiles: _propTypes["default"].bool,

  /**
   * A map of viewport widths to number of columns.  For example:
   * ```
   *  cols={{
   *    xs: 2,
   *    sm: 3,
   *    md: 4,
   *    lg: 5,
   *    xl: 5
   *  }}
   * ```
   */
  cols: _propTypes["default"].shape({
    xs: _propTypes["default"].number,
    sm: _propTypes["default"].number,
    md: _propTypes["default"].number,
    lg: _propTypes["default"].number,
    xl: _propTypes["default"].number
  }),

  /**
   * The spacing between the tiles in theme spacing units.
   */
  spacing: _propTypes["default"].number
};
ResponsiveTiles.defaultProps = {
  autoScrollToNewTiles: false,
  cols: {
    xs: 2,
    sm: 3,
    md: 4,
    lg: 5,
    xl: 5
  },
  spacing: 1
};

function createTiles(_ref) {
  var cols = _ref.cols,
      spacing = _ref.spacing;
  var useStyles = (0, _styles.makeStyles)(function (theme) {
    var breakpoints = {}; // Breakpoints MUST be set in order from smallest to largest

    Object.keys(cols).map(function (width) {
      return {
        key: width,
        value: cols[width],
        width: "".concat(100 / cols[width], "%")
      };
    }).sort(function (a, b) {
      return a.value - b.value;
    }).forEach(function (_ref2) {
      var key = _ref2.key,
          width = _ref2.width;
      breakpoints[theme.breakpoints.up(key)] = {
        width: width
      };
    });
    return {
      root: {
        display: 'flex',
        flexWrap: 'wrap',
        overflowY: 'auto',
        listStyle: 'none',
        padding: 0,
        margin: "-".concat(theme.spacing(spacing), "px"),
        WebkitOverflowScrolling: 'touch' // Add iOS momentum scrolling.

      },
      tile: _objectSpread(_objectSpread({}, breakpoints), {}, {
        padding: "".concat(theme.spacing(spacing), "px"),
        height: 'auto'
      })
    };
  }, 'RSFResponsiveTiles');

  function maybeWrapInAutoScroll(doWrap) {
    return function (elements) {
      if (doWrap) {
        return /*#__PURE__*/_react["default"].createElement(_AutoScrollToNewChildren["default"], null, elements);
      } else {
        return elements;
      }
    };
  }

  return function Tiles(_ref3) {
    var className = _ref3.className,
        classes = _ref3.classes,
        autoScrollToNewTiles = _ref3.autoScrollToNewTiles,
        children = _ref3.children,
        other = (0, _objectWithoutProperties2["default"])(_ref3, ["className", "classes", "autoScrollToNewTiles", "children"]);
    classes = useStyles({
      classes: classes
    });
    return /*#__PURE__*/_react["default"].createElement("ul", (0, _extends2["default"])({
      className: (0, _clsx["default"])(className, classes.root)
    }, other), maybeWrapInAutoScroll(autoScrollToNewTiles)(_react["default"].Children.map(children, function (child, i) {
      if (! /*#__PURE__*/_react["default"].isValidElement(child)) {
        return null;
      }

      return /*#__PURE__*/_react["default"].createElement(_GridListTile["default"], {
        key: i,
        classes: {
          root: classes.tile
        }
      }, child);
    })));
  };
}
//# sourceMappingURL=ResponsiveTiles.js.map